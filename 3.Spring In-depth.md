### Spring Framework Mein Bean Scopes - Hinglish Mein Samjhein

Spring Framework beans ke **scopes** ko manage karta hai, jo decide karta hai ki ek bean kitni der tak exist karega, kitne instances banenge, aur kaise share honge. Chaliye isko detail mein Hinglish mein samjhte hain, saath hi kuch code examples, text diagrams, aur ek yaadgar Hinglish joke ke saath!

---

### **Bean Scopes Ke Types**

1. **Singleton Scope:** Ek hi instance pura application mein share hota hai.
2. **Prototype Scope:** Har request pe naya instance banta hai.
3. **Request Scope (Web-specific):** Har HTTP request ke liye ek naya bean banta hai.
4. **Session Scope (Web-specific):** Har HTTP session ke liye ek naya bean banta hai.
5. **Application Scope (Web-specific):** Puri application ke liye ek hi bean.
6. **Websocket Scope (Web-specific):** Har WebSocket session ke liye ek naya bean.

---

### **Singleton Scope (Default)**

- **Definition:** Spring ek **single shared instance** banata hai aur har request pe wahi reference return karta hai.
- **Use Case:** Best **stateless** beans ke liye, jaise service classes, jahan state maintain karne ki zarurat nahi hai.
- **Example:**

```java
@Component
public class ContentBasedFilter {
    // Service logic here
}
```

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(Application.class, args);

        ContentBasedFilter cbf1 = appContext.getBean(ContentBasedFilter.class);
        ContentBasedFilter cbf2 = appContext.getBean(ContentBasedFilter.class);
        ContentBasedFilter cbf3 = appContext.getBean(ContentBasedFilter.class);

        System.out.println(cbf1);
        System.out.println(cbf2);
        System.out.println(cbf3);
    }
}
```

**Output:**
```
ContentBasedFilter@1f34b3a
ContentBasedFilter@1f34b3a
ContentBasedFilter@1f34b3a
```

**Explanation:**
Sabhi variables (`cbf1`, `cbf2`, `cbf3`) **same memory address** point karte hain kyunki sirf ek hi instance create hua hai.

**Text Diagram:**
```
Singleton Bean: ContentBasedFilter
        |
        |--- cbf1 --> Same Instance
        |--- cbf2 --> Same Instance
        |--- cbf3 --> Same Instance
```

---

### **Prototype Scope**

- **Definition:** **Har request** pe naya instance create hota hai jab bean ko request kiya jata hai.
- **Use Case:** Best **stateful** beans ke liye, jaise DAO (Data Access Objects), jahan alag-alag objects chahiye har request ke liye.
- **Implementation:**
  @Scope annotation use karke prototype define karein.

```java
@Component
@Scope("prototype")
public class CollaborativeFilter {
    // DAO logic here
}
```

**Code Example:**

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(Application.class, args);

        CollaborativeFilter cf1 = appContext.getBean(CollaborativeFilter.class);
        CollaborativeFilter cf2 = appContext.getBean(CollaborativeFilter.class);
        CollaborativeFilter cf3 = appContext.getBean(CollaborativeFilter.class);

        System.out.println(cf1);
        System.out.println(cf2);
        System.out.println(cf3);
    }
}
```

**Output:**
```
CollaborativeFilter@2a4d5c6
CollaborativeFilter@3b6e7d8
CollaborativeFilter@4c7f9e0
```

**Explanation:**
Har variable (`cf1`, `cf2`, `cf3`) **different memory addresses** point karte hain kyunki har request pe naya instance create hota hai.

**Text Diagram:**
```
Prototype Bean: CollaborativeFilter
        |
        |--- cf1 --> New Instance
        |--- cf2 --> New Instance
        |--- cf3 --> New Instance
```

---

### **Key Differences: Singleton vs. Prototype**

| **Feature**              | **Singleton Scope**                          | **Prototype Scope**                          |
|--------------------------|----------------------------------------------|----------------------------------------------|
| **Number of Instances**  | Sirf **ek hi instance** create hota hai.      | **Multiple instances** create hote hain.      |
| **Lifecycle**            | Bean **startup** pe create aur cache hota hai.| Bean **har request** pe create hota hai.     |
| **Sharing**              | Same instance pura app mein share hota hai.   | Alag-alag instances har request mein use hote hain. |
| **Use Case**             | Stateless components (e.g., services).        | Stateful components (e.g., DAOs).            |

---

### **Spring Singleton vs. Gang of Four (GoF) Singleton**

- **GoF Singleton:** Sirf **ek instance per JVM**.
- **Spring Singleton:** Sirf **ek instance per application context**.
    - **Example:** Agar ek JVM mein multiple application contexts hain, toh har context ka apna singleton instance hoga.

**Text Diagram:**
```
JVM
â”‚
â”œâ”€â”€ Application Context 1 (Singleton Bean A)
â””â”€â”€ Application Context 2 (Singleton Bean A)
```

---

### **Summary**

- **Singleton Scope:** Default aur best for stateless beans, kyunki memory save hoti hai sharing instances se.
- **Prototype Scope:** Use karein jab har request pe alag instance chahiye.

** Joke Time!**

> **Q:** Ek singleton bean aur prototype bean mein kya fark hai?
>
> **A:** Singleton hamesha ek hi "gandagi" uthata hai, jabki prototype har baar nayi "gandagi" le aata hai! ğŸ˜…

*(Yahan "gandagi" ka matlab hai instance, yaani ek hi instance baar-baar use hone se issues aa sakte hain!)*

---

### JVM aur Application Context: Beginners Ke Liye Samajh

#### **1. JVM Kya Hai?**

- **JVM (Java Virtual Machine):** Woh environment jahan aapka Java application run hota hai. Ye Java code (.class files) ko machine-readable instructions mein translate karta hai.
- **JVM Ke Responsibilities:**
  - Memory allocate karna.
  - Java application run karna.
  - Garbage collection manage karna (unused memory free karna).

ğŸ‘‰ **JVM ko sochiye ek computer ke tarah jo aapke Java programs ko chalata hai.**

---

#### **2. Application Context Kya Hai?**

- **Spring Mein Application Context:** Woh container jo aapke beans (Spring ke objects) ke lifecycle ko manage karta hai.
- **Application Context Ke Features:**
  - Beans create karna jab application start hota hai.
  - Beans ke beech dependencies manage karna.
  - Dependency injection aur bean scopes provide karna.

ğŸ‘‰ **Application Context ko sochiye ek manager ke tarah jo aapke Spring application ke objects ko organize aur connect karta hai.**

---

#### **JVM aur Application Context Ka Relation**

1. **JVM Application Context Chalata Hai:**
   - Spring application start karne pe, JVM aapka program run karta hai.
   - JVM ke andar, Spring framework **Application Context** initialize karta hai, jo beans manage karta hai.

2. **Ek JVM Mein Multiple Application Contexts Chal Sakte Hain:**
   - Aap ek hi JVM mein multiple **Application Contexts** bana sakte hain.
   - Har Application Context apne alag beans manage karta hai. Ek context ke beans doosre context ke beans se directly interact nahi kar sakte.

3. **Spring Singleton Scope Application Context Pe Depend Karta Hai:**
   - **Spring Singleton** ka matlab hai ek bean per **Application Context**, na ki per JVM.
   - Agar aap ek JVM mein multiple Application Contexts banate hain, toh har context ka apna singleton instance hoga.

---

### **Example: Ek JVM Mein Multiple Application Contexts**

Sochiye aapke paas ek JVM hai jo aapka Java application run kar raha hai, aur aap do alag Application Contexts bana rahe hain:

1. **First Application Context:**
   - **User Management System** ke beans manage karta hai.
   - **Singleton Bean:** UserService.

2. **Second Application Context:**
   - **Order Management System** ke beans manage karta hai.
   - **Singleton Bean:** OrderService.

**Key Point:** Dono Application Contexts ek hi JVM mein chal rahe hain, par har context apne beans independently manage karta hai. Ek context ka singleton doosre context ke singleton se related nahi hai.

**Text Diagram:**
```
JVM (Ek Running Instance)
â”‚
â”œâ”€â”€ Application Context 1
â”‚   â”œâ”€â”€ UserService (Singleton)
â”‚   â”œâ”€â”€ EmployeeService (Prototype)
â”‚
â”œâ”€â”€ Application Context 2
    â”œâ”€â”€ OrderService (Singleton)
    â”œâ”€â”€ InventoryService (Prototype)
```

---

### **Visual Diagram**

```
JVM (One Running Instance)
â”‚
â”œâ”€â”€ Application Context 1
â”‚   â”œâ”€â”€ Bean A (Singleton)
â”‚   â”œâ”€â”€ Bean B (Prototype)
â”‚
â”œâ”€â”€ Application Context 2
    â”œâ”€â”€ Bean A (Singleton - Separate from Context 1)
    â”œâ”€â”€ Bean C (Prototype)
```

---

### **Real-Life Analogy**

Sochiye **JVM** ek **bada office building** hai. Is building ke andar do **departments** hain:

1. **User Management Department:**
   - Employees (beans jaise EmployeeService, PayrollService) manage karta hai.

2. **Order Management Department:**
   - Employees (beans jaise OrderService, InventoryService) manage karta hai.

Har department apne kaam ko independently manage karta hai, bhale hi woh same building mein hain. Agar building (JVM) band ho jati hai, dono departments (contexts) ruk jate hain.

---

### **Simple Terms Mein**

- **JVM:** Engine jo aapka application run karta hai.
- **Application Context:** Framework jo aapke app ke objects (beans) ko manage aur connect karta hai.
- **Spring Singleton Scope:** "Ek bean per Application Context," na ki "Ek bean per JVM."

Agar aapko aur clarity chahiye, toh poochne mein hichkichaiye mat! ğŸ˜Š

---

### **Mixing Bean Scope - Hinglish Mein Samjhein**

Spring Framework mein **bean scope** ka matlab hota hai ki ek bean ka lifecycle kaise manage hoga, kitne instances create honge, aur unka use kaise hoga. Jab hum ek **singleton bean** ke andar ek **prototype bean** inject karte hain, toh kuch unexpected behavior aa sakta hai. Chaliye ise detail mein samajhte hain.

---

### **Problem: Singleton Bean with Prototype Dependency**

1. **Singleton Bean:** Ye ek hi baar banta hai aur pura application usi ek instance ko use karta hai.
2. **Prototype Bean:** Ye har baar naye object ko create karta hai jab bhi usse request kiya jaye.

**Issue:**
Agar ek singleton bean ke andar ek prototype bean inject karte hain, toh **singleton bean ke banne ke waqt hi** prototype bean inject ho jata hai. Iska matlab ye hai ki prototype ka "naya object create karne ka behavior" kaam nahi karega.

---

### **Images ka Explanation**

#### **Image 1: Singleton ke andar Prototype (Galat Behavior)**

- **ContentBasedFilter** ek **singleton** bean hai.
- **Movie** ek **prototype** bean hai.

**Expectation:**
- Jab bhi `getMovie()` call karenge, ek **naya Movie instance** milega.

**Reality:**
- Jab **ContentBasedFilter** singleton create hota hai, tab hi ek hi **Movie object** inject ho jata hai.
- Har baar `getMovie()` call karne par **same Movie instance** return hota hai.

---

#### **Image 2: Prototype Behavior Lost**

Yaha prototype ka behavior "disappear" ho jata hai kyunki **Movie** ka ek hi instance **singleton bean** ke initialization ke waqt inject hota hai. Fir us **Movie** instance ko baar-baar reuse kiya jata hai.

**Problem:**
- Prototype ka asli fayda nahi milta.
- Ek hi object baar-baar use ho raha hai, jo galat behavior hai.

---

#### **Image 3: Proxy ka Solution**

Yaha hum **proxy** use karke problem solve karte hain.

- **Proxy** ek **placeholder object** hota hai jo singleton mein inject hota hai.
- Jab bhi `getMovie()` call karenge, proxy ensure karega ki ek **naya Movie instance** create ho.

---

### **Solution Ke Tarike**

#### **1. Proxy Mode Use Karna**

Apne `@Scope` annotation mein proxy mode add kijiye:

```java
@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class Movie {
    public Movie() {
        System.out.println("Movie constructor called");
    }
}
```

**Kaise Kaam Karta Hai?**
- **Proxy** real object ke jagah ek dummy object inject karta hai.
- Jab aap `getMovie()` call karte ho, proxy ek **naya Movie instance** create kar deta hai.

---

#### **2. @Lookup Annotation Use Karna**

`@Lookup` ka matlab hai ki Spring har baar ek **naya bean** dega jab method call hoga.

**Code Example:**

```java
@Component
public class ContentBasedFilter {
    @Lookup
    public Movie getMovie() {
        return null; // Spring is method ko override karega
    }
}
```

**Kaise Kaam Karta Hai?**
- Spring `getMovie()` method ko override karta hai.
- Jab bhi method call hota hai, ek **naya Movie object** create hota hai.

---

### **Conclusion**

Agar aapko **singleton ke andar prototype** ka behavior chahiye, toh ye do solutions hain:

1. **Proxy Mode:** Proxy ke through Spring naya object deta hai.
2. **@Lookup Annotation:** Har call par naya bean create hota hai.

---

### **Output Example**

**Galat Behavior (Without Fix):**

```
ContentBasedFilter constructor called
Movie constructor called (SIRF 1 BAAR)

Movie Instances:
Movie@1f34b3a
Movie@1f34b3a
Movie@1f34b3a
```

**Sahi Behavior (Proxy/Lookup ke Saath):**

```
ContentBasedFilter constructor called
Movie constructor called (3 BAAR)

Movie Instances:
Movie@1f34b3a
Movie@2a4d5c6
Movie@3b6e7d8
```

Ab `getMovie()` har baar ek **naya Movie object** deta hai, jo sahi behavior hai.

---

### **Mixing Bean Scope - Detailed Explanation in Hinglish**

Aapko samajhne ke liye hum "Mixing Bean Scope" problem ko step-by-step aur examples ke saath samjhayenge. Yaha hum **singleton** aur **prototype** bean ke beech ka relation samajhne ki koshish karenge, aur kaise ye galat behavior de sakta hai uska solution dekhenge.

---

### **Bean Scopes Basics**

1. **Singleton Scope:**
   - **Ek baar banega** aur application ke andar har jagah use hoga.
   - **Example:** Ek service jo puri application ke liye common hai.
   - **Diagram:**

    ```
    Singleton Bean -> Same Object -> Used Everywhere
    ```

2. **Prototype Scope:**
   - **Har baar naya object banega**, jab bhi usse request kiya jaye.
   - **Example:** Ek temporary object jo sirf ek specific task ke liye chahiye.
   - **Diagram:**

    ```
    Prototype Bean -> Different Object -> Every Request
    ```

---

### **Problem: Singleton Bean with Prototype Dependency**

#### **Scenario**
- Aapke paas ek **singleton bean** hai (`ContentBasedFilter`).
- Usme ek **prototype bean** (`Movie`) inject karte hain.

#### **Expectation:**
- Jab bhi hum `getMovie()` method call karein, hume ek **naya Movie object** mile.

#### **Reality:**
- **Galat Behavior** hota hai:
  - Prototype ka ek hi instance `ContentBasedFilter` ke saath inject ho jata hai.
  - Ab `getMovie()` method har baar wahi **same Movie object** return karega.

---

### **Galat Behavior Diagram**

#### **Diagram 1: Singleton ke andar Prototype ka galat behavior**

```
ContentBasedFilter (Singleton)
        |
        -> Movie Instance (Prototype) -> SAME OBJECT
        -> Movie Instance (Prototype) -> SAME OBJECT
        -> Movie Instance (Prototype) -> SAME OBJECT
```

- Yaha har baar ek hi **Movie object** return hota hai.
- Prototype ka behavior **kaam nahi kar raha hai**.

#### **Code Example**

```java
@Component
@Scope("singleton")
public class ContentBasedFilter {
    @Autowired
    private Movie movie;

    public Movie getMovie() {
        return movie;
    }
}

@Component
@Scope("prototype")
public class Movie {
    public Movie() {
        System.out.println("Movie constructor called");
    }
}
```

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(Application.class, args);

        ContentBasedFilter filter = appContext.getBean(ContentBasedFilter.class);
        Movie movie1 = filter.getMovie();
        Movie movie2 = filter.getMovie();
        Movie movie3 = filter.getMovie();

        System.out.println(movie1);
        System.out.println(movie2);
        System.out.println(movie3);
    }
}
```

**Output (Galat Behavior):**
```
ContentBasedFilter constructor called
Movie constructor called (SIRF 1 BAAR)

Movie Instances:
Movie@1f34b3a
Movie@1f34b3a
Movie@1f34b3a
```

---

### **Solution 1: Proxy Mode**

#### **Proxy Kya Hai?**
- **Proxy** ek **placeholder object** hai jo singleton mein inject hota hai.
- Jab `getMovie()` method call hota hai, proxy ek **naya Movie object** return karta hai.

#### **Proxy Kaam Kaise Karta Hai?**
1. Proxy ko `ContentBasedFilter` ke andar inject karte hain.
2. Jab `getMovie()` call hota hai, proxy Spring se naya **Movie object** leta hai.
3. Har baar `getMovie()` ke liye ek alag object create hota hai.

#### **Diagram 2: Proxy Mode Ka Behavior**

```
ContentBasedFilter (Singleton)
        |
        -> Proxy Object
            |
            -> Movie Instance 1 (Prototype)
            -> Movie Instance 2 (Prototype)
            -> Movie Instance 3 (Prototype)
```

#### **Code Example**

```java
@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class Movie {
    public Movie() {
        System.out.println("Movie constructor called");
    }
}

@Component
public class ContentBasedFilter {
    @Autowired
    private Movie movie; // Proxy inject hoga

    public Movie getMovie() {
        return movie;
    }
}
```

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(Application.class, args);

        ContentBasedFilter filter = appContext.getBean(ContentBasedFilter.class);
        System.out.println("\nContentBasedFilter Bean: " + filter);

        Movie movie1 = filter.getMovie();
        Movie movie2 = filter.getMovie();
        Movie movie3 = filter.getMovie();

        System.out.println("\nMovie Beans:");
        System.out.println(movie1);
        System.out.println(movie2);
        System.out.println(movie3);

        System.out.println("\nInstances Created:");
        System.out.println("Movie Instances: " + Movie.getInstances());
    }
}
```

**Expected Output:**
```
ContentBasedFilter constructor called
Movie constructor called (1st Instance)

ContentBasedFilter Bean: ContentBasedFilter@1f34b3a

Movie constructor called (2nd Instance)
Movie constructor called (3rd Instance)
Movie constructor called (4th Instance)

Movie Beans:
Movie@2a4d5c6
Movie@3b6e7d8
Movie@4d6f8g9

Instances Created:
Movie Instances: 3
```

---

### **Solution 2: @Lookup Annotation**

#### **@Lookup Kya Karta Hai?**
- `@Lookup` method ko override karta hai.
- Jab bhi `getMovie()` method call hota hai, Spring ek **naya bean** return karta hai.

#### **Diagram 3: Lookup Behavior**

```
ContentBasedFilter (Singleton)
        |
        -> getMovie() -> Movie Instance 1 (Prototype)
        -> getMovie() -> Movie Instance 2 (Prototype)
        -> getMovie() -> Movie Instance 3 (Prototype)
```

#### **Code Example**

```java
@Component
public class ContentBasedFilter {
    @Lookup
    public Movie getMovie() {
        return null; // Spring ise override karega
    }
}

@Component
@Scope("prototype")
public class Movie {
    public Movie() {
        System.out.println("Movie constructor called");
    }
}
```

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(Application.class, args);

        ContentBasedFilter filter = appContext.getBean(ContentBasedFilter.class);
        Movie movie1 = filter.getMovie();
        Movie movie2 = filter.getMovie();
        Movie movie3 = filter.getMovie();

        System.out.println(movie1);
        System.out.println(movie2);
        System.out.println(movie3);
    }
}
```

**Output (Lookup Mode):**
```
ContentBasedFilter constructor called
Movie constructor called (1st Instance)
Movie constructor called (2nd Instance)
Movie constructor called (3rd Instance)

Movie Instances:
Movie@1f34b3a
Movie@2a4d5c6
Movie@3b6e7d8
```

---

### **Comparison**

| **Solution**     | **Advantage**                              | **Use Case**                     |
|------------------|--------------------------------------------|-----------------------------------|
| **Proxy Mode**   | Easy to implement, automatic dependency.  | Default choice for prototype.    |
| **@Lookup**      | Manual control over object creation.      | Advanced use cases or testing.    |

---

### **Conclusion**

Agar aapke singleton bean ke andar prototype ka behavior chahiye, toh ye do solutions hain:

1. **Proxy Mode:** Proxy ke through Spring naya object deta hai. Ye easy aur automatic hai.
2. **@Lookup Annotation:** Har call par naya bean create hota hai. Ye advanced scenarios ya testing ke liye useful hai.

Aapke problem ka solution depend karega ki aapka **use case** kya hai aur kitna control chahiye. **Proxy mode** zyada tar cases mein sahi kaam karega aur prototype ka asli behavior restore karega.

---

### **Explanation of @Scope with Proxy Mode in Simple Terms (Hinglish Mein)**

---

### **Purpose**

`@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)` Spring mein use hota hai **prototype** scope define karne ke liye aur **proxy** apply karne ke liye jab bean ko singleton ke andar inject karte hain.

---

### **Breaking it Down**

#### **1. @Scope**

- **@Scope Annotation:** Bean ke **lifecycle** ko define karta hai Spring mein (e.g., singleton, prototype, etc.).

---

#### **2. ConfigurableBeanFactory.SCOPE_PROTOTYPE**

- **Prototype Scope:**
  - **Har baar naya object** create hota hai jab bean ko request kiya jata hai.
  - **Example:**

    ```java
    @Component
    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
    public class Movie {
        public Movie() {
            System.out.println("Movie Constructor Called");
        }
    }
    ```

  - **Behavior:**
    - Jab `getBean(Movie.class)` call karenge, **har baar naya object** milega.
    - **Output:**

    ```
    Movie Constructor Called
    Movie Constructor Called
    ```

---

#### **3. proxyMode = ScopedProxyMode.TARGET_CLASS**

- **Proxy:** Ek **placeholder** hota hai jo original object ko **represent** karta hai.
- Jab proxy inject hota hai aur koi method call hoti hai, Spring runtime par **naya object** create karta hai (prototype ka asli behavior ensure karta hai).

**Proxy Modes:**
- **ScopedProxyMode.TARGET_CLASS:**
  - Proxy ko **class-based** banata hai.
  - Class-level proxy use hota hai (interface ki jagah).
  - Useful jab implementation class ko directly use karna ho (e.g., Movie class).

- **ScopedProxyMode.INTERFACES:**
  - Proxy ko **interface-based** banata hai.
  - Useful jab bean koi interface implement kar raha ho.

---

### **Why Use Proxy with Prototype Scope?**

- Jab **prototype bean** ek **singleton bean** ke andar inject hota hai, toh prototype ka behavior **lose** ho jata hai.
- Proxy ensure karta hai ki har baar nayi request par prototype ka **naya object** mile.

---

### **Example Code**

#### **Movie Class**

```java
@Component
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class Movie {
    private static int instances = 0;

    public Movie() {
        instances++;
        System.out.println("Movie Constructor Called. Instance: " + instances);
    }

    public static int getInstances() {
        return instances;
    }
}
```

#### **ContentBasedFilter Class**

```java
@Component
public class ContentBasedFilter {
    @Autowired
    private Movie movie; // Proxy inject hoga

    public Movie getMovie() {
        return movie;
    }
}
```

#### **Main Application**

```java
@SpringBootApplication
public class MovieRecommenderSystemApplication {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(MovieRecommenderSystemApplication.class, args);

        // Get singleton bean
        ContentBasedFilter filter = appContext.getBean(ContentBasedFilter.class);
        System.out.println("\nContentBasedFilter Bean: " + filter);

        // Request prototype beans via singleton
        Movie movie1 = filter.getMovie();
        Movie movie2 = filter.getMovie();
        Movie movie3 = filter.getMovie();

        System.out.println("\nMovie Beans:");
        System.out.println(movie1);
        System.out.println(movie2);
        System.out.println(movie3);

        System.out.println("\nInstances Created:");
        System.out.println("Movie Instances: " + Movie.getInstances());
    }
}
```

**Expected Output:**
```
Movie Constructor Called. Instance: 1
ContentBasedFilter Bean: ContentBasedFilter@1f34b3a

Movie Constructor Called. Instance: 2
Movie Constructor Called. Instance: 3
Movie Constructor Called. Instance: 4

Movie Beans:
Movie@2a4d5c6
Movie@3b6e7d8
Movie@4d6f8g9

Instances Created:
Movie Instances: 3
```

---

### **How Proxy Works (Diagram)**

1. **Without Proxy (Galat Behavior):**

```
ContentBasedFilter (Singleton)
        |
        -> Movie (Prototype) -> SAME INSTANCE
```

2. **With Proxy (Sahi Behavior):**

```
ContentBasedFilter (Singleton)
        |
        -> Proxy (Placeholder)
            |
            -> Movie Instance 1 (Prototype)
            -> Movie Instance 2 (Prototype)
            -> Movie Instance 3 (Prototype)
```

---

### **Key Benefits**

1. **Prototype Behavior Restore:**
   - Proxy ensure karta hai ki **nayi request par naya object** mile.

2. **Class-Based Proxy:**
   - Direct implementation class ke liye suitable (e.g., Movie class).

3. **Encapsulation:**
   - Singleton bean ka lifecycle manage hota hai without prototype behavior lose kiye.

---

### **When to Use Proxy?**

- Jab **singleton bean** ke andar **prototype bean** chahiye aur uska asli behavior chahiye.
- **Use Cases:**
  - Temporary ya stateful objects (e.g., database connections, session-specific objects).

---

### **Summary**

- `@Scope` ke saath `proxyMode` use karna zaruri hai jab **singleton bean ke andar prototype ka behavior chahiye**.
- **Proxy** ek **placeholder** hota hai jo runtime par naya object fetch karta hai.
- **Class-level proxies** ke liye `ScopedProxyMode.TARGET_CLASS` use hota hai.

Aap isko apne use case ke hisaab se easily implement kar sakte hain!

---

### **Final Joke for Memory**

> **Q:** Spring mein singleton aur prototype bean ka fight kaise hota hai?
>
> **A:** Singleton bolta hai, "Main hi boss hoon yahan!" Prototype kehta hai, "Arre bhai, mujhe har baar naya samjho!" ğŸ˜‚

*(Yahan, "boss" ka matlab hai ek hi instance hona, aur "har baar naya samjho" matlab prototype bean ka alag-alag instance create hona!)*

---

### Spring Framework Mein @ComponentScan - Hinglish Mein Samjhein

Spring Framework mein **@ComponentScan** kaafi important role play karta hai, especially jab aapko alag-alag packages mein beans ko manage karna ho. Is topic ko hum detail mein Hinglish mein samjhenge, saath hi kuch aur code examples, text diagrams, aur ek yaadgar Hinglish joke ke saath! Chaliye shuru karte hain! ğŸš€

---

### **@ComponentScan Kya Hai?**

Spring application mein, **@ComponentScan** annotation Spring ko batata hai ki woh kin packages mein jaake beans (components) ko dhundhega jo uske management mein aayenge. Ye beans **@Component**, **@Repository**, **@Service**, aur **@Controller** jaise annotations se mark kiye hote hain.

---

### **@SpringBootApplication Aur @ComponentScan**

**@SpringBootApplication** annotation Spring Boot applications ke liye kaafi powerful hai. Ye actually teen annotations ka combination hai:

1. **@Configuration:** Bean definitions ke liye.
2. **@EnableAutoConfiguration:** Spring Boot ko automatic configurations enable karta hai.
3. **@ComponentScan:** Beans ko scan karne ke liye.

```java
@SpringBootApplication
public class MovieRecommenderSystemApplication {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(MovieRecommenderSystemApplication.class, args);
        System.out.println("ContentBasedFilter bean found = " + appContext.containsBean("contentBasedFilter"));
        System.out.println("CollaborativeFilter bean found = " + appContext.containsBean("collaborativeFilter"));
    }
}
```

**Explanation:**
- **@SpringBootApplication** automatically scan karta hai wahi package jahan ye annotation present hai aur uske sub-packages mein.
- Agar aapke beans kisi aur package mein hain, toh Spring unhe scan nahi karega jab tak aap explicitly **@ComponentScan** use na karein.

---

### **@ComponentScan Ke Features**

1. **Base Packages Specify Karna:**
   - Agar beans alag packages mein hain, toh aap **@ComponentScan** ke **basePackages** attribute ka use karke specify kar sakte hain.

2. **Include Aur Exclude Filters:**
   - Kuch specific beans ko include ya exclude karne ke liye filters ka use kar sakte hain.

3. **Filter Types:**
   - **ANNOTATION**, **ASPECTJ**, **ASSIGNABLE_TYPE**, **REGEX**, aur **CUSTOM** filters available hain.

---

### **Example: Beans Different Packages Mein**

**Project Structure:**
```
io.datajek.spring.basics.movierecommendersystem
â”‚
â”œâ”€â”€ lesson9
â”‚   â”œâ”€â”€ MovieRecommenderSystemApplication.java
â”‚   â”œâ”€â”€ ContentBasedFilter.java
â”‚   â””â”€â”€ Movie.java
â”‚
â””â”€â”€ lesson10
    â””â”€â”€ CollaborativeFilter.java
```

**ContentBasedFilter.java (lesson9):**
```java
package io.datajek.spring.basics.movierecommendersystem.lesson9;

import org.springframework.stereotype.Component;

@Component
public class ContentBasedFilter {
    // Content-based filtering logic
}
```

**CollaborativeFilter.java (lesson10):**
```java
package io.datajek.spring.basics.movierecommendersystem.lesson10;

import org.springframework.stereotype.Component;

@Component
public class CollaborativeFilter {
    // Collaborative filtering logic
}
```

**MovieRecommenderSystemApplication.java (lesson9):**
```java
package io.datajek.spring.basics.movierecommendersystem.lesson9;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

@SpringBootApplication
public class MovieRecommenderSystemApplication {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(MovieRecommenderSystemApplication.class, args);
        System.out.println("ContentBasedFilter bean found = " + appContext.containsBean("contentBasedFilter"));
        System.out.println("CollaborativeFilter bean found = " + appContext.containsBean("collaborativeFilter"));
    }
}
```

**Expected Output Without @ComponentScan:**
```
ContentBasedFilter bean found = true
CollaborativeFilter bean found = false
```

**Explanation:**
- **@SpringBootApplication** scan karta hai **lesson9** package aur uske sub-packages ko.
- **ContentBasedFilter** bean same package mein hai, isliye mil jata hai.
- **CollaborativeFilter** alag package (**lesson10**) mein hai, isliye nahi milta.

---

### **@ComponentScan Use Karke Specific Package Scan Karna**

Agar aap chahte hain ki Spring alag package **lesson10** ko bhi scan kare, toh aap **@ComponentScan** ka use kar sakte hain.

```java
package io.datajek.spring.basics.movierecommendersystem.lesson9;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = "io.datajek.spring.basics.movierecommendersystem.lesson10")
public class MovieRecommenderSystemApplication {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(MovieRecommenderSystemApplication.class, args);
        System.out.println("ContentBasedFilter bean found = " + appContext.containsBean("contentBasedFilter"));
        System.out.println("CollaborativeFilter bean found = " + appContext.containsBean("collaborativeFilter"));
    }
}
```

**Expected Output With @ComponentScan:**
```
ContentBasedFilter bean found = false
CollaborativeFilter bean found = true
```

**Explanation:**
- Ab Spring sirf **lesson10** package ko scan karega.
- **CollaborativeFilter** milta hai, **ContentBasedFilter** nahi milta kyunki woh **lesson9** package mein hai.

---

### **Include Aur Exclude Filters Ka Use**

Agar aap multiple packages ko scan karna chahte hain, toh **basePackages** mein unke paths list kar sakte hain.

```java
@ComponentScan(basePackages = {
    "io.datajek.spring.basics.movierecommendersystem.lesson9",
    "io.datajek.spring.basics.movierecommendersystem.lesson10"
})
```

**With Multiple Base Packages:**
```java
package io.datajek.spring.basics.movierecommendersystem.lesson9;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = {
    "io.datajek.spring.basics.movierecommendersystem.lesson9",
    "io.datajek.spring.basics.movierecommendersystem.lesson10"
})
public class MovieRecommenderSystemApplication {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(MovieRecommenderSystemApplication.class, args);
        System.out.println("ContentBasedFilter bean found = " + appContext.containsBean("contentBasedFilter"));
        System.out.println("CollaborativeFilter bean found = " + appContext.containsBean("collaborativeFilter"));
    }
}
```

**Expected Output:**
```
ContentBasedFilter bean found = true
CollaborativeFilter bean found = true
```

**Explanation:**
- Ab Spring dono packages (**lesson9** aur **lesson10**) ko scan karta hai.
- Dono beans mil jaate hain.

---

### **Filters Types Samjhein**

**@ComponentScan** mein filters ka use karke aap specify kar sakte hain ki kaunse beans ko include ya exclude karna hai. Filters ke types hain:

1. **ANNOTATION:** Specific annotation wale beans ko include/exclude.
2. **ASPECTJ:** AspectJ expressions ke through.
3. **ASSIGNABLE_TYPE:** Specific class types ko include/exclude.
4. **REGEX:** Regular expressions ka use.
5. **CUSTOM:** Custom filter implementations.

**Example: Include Filters with REGEX**

```java
package io.datajek.spring.basics.movierecommendersystem.lesson9;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;

@SpringBootApplication
@ComponentScan(
    basePackages = "io.datajek.spring.basics.movierecommendersystem.lesson10",
    includeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = "io\\.datajek\\.spring\\.basics\\.movierecommendersystem\\.lesson9\\..*"
    )
)
public class MovieRecommenderSystemApplication {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(MovieRecommenderSystemApplication.class, args);
        System.out.println("ContentBasedFilter bean found = " + appContext.containsBean("contentBasedFilter"));
        System.out.println("CollaborativeFilter bean found = " + appContext.containsBean("collaborativeFilter"));
    }
}
```

**Expected Output:**
```
ContentBasedFilter bean found = true
CollaborativeFilter bean found = true
```

**Explanation:**
- **basePackages** mein **lesson10** specify kiya gaya hai.
- **includeFilters** mein **lesson9** package ko bhi include kiya gaya hai using REGEX.
- Ab dono packages scan hote hain aur dono beans mil jaate hain.

---

### **Text Diagrams Se Samjhein**

**1. Without @ComponentScan (Default Behavior):**

```
@SpringBootApplication
      |
      |--- Scans: lesson9 package
      |
      |--- ContentBasedFilter bean found
      |--- CollaborativeFilter bean NOT found
```

**2. With @ComponentScan for Specific Package:**

```
@SpringBootApplication
@ComponentScan(basePackages = "lesson10")
      |
      |--- Scans: lesson10 package
      |
      |--- ContentBasedFilter bean NOT found
      |--- CollaborativeFilter bean found
```

**3. With Multiple Base Packages and Include Filters:**

```
@SpringBootApplication
@ComponentScan(
    basePackages = "lesson10",
    includeFilters = REGEX for "lesson9.*"
)
      |
      |--- Scans: lesson10 and lesson9 packages
      |
      |--- ContentBasedFilter bean found
      |--- CollaborativeFilter bean found
```

---

### **Code Example: Running Without Aur With @ComponentScan**

**Without @ComponentScan:**
- **ContentBasedFilter** milta hai.
- **CollaborativeFilter** nahi milta.

**With @ComponentScan (Lesson10):**
- **CollaborativeFilter** milta hai.
- **ContentBasedFilter** nahi milta.

**With @ComponentScan (Both Lesson9 & Lesson10):**
- Dono beans milte hain.

**Code Snippet:**

```java
package io.datajek.spring.basics.movierecommendersystem.lesson9;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;

@SpringBootApplication
// @ComponentScan(basePackages = "io.datajek.spring.basics.movierecommendersystem.lesson10")
// @ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = "io.datajek.spring.basics.movierecommendersystem.lesson9.*"))
public class MovieRecommenderSystemApplication {
    public static void main(String[] args) {
        ApplicationContext appContext = SpringApplication.run(MovieRecommenderSystemApplication.class, args);
        System.out.println("CollaborativeFilter bean found = " + appContext.containsBean("collaborativeFilter"));
        System.out.println("ContentBasedFilter bean found = " + appContext.containsBean("contentBasedFilter"));
    }
}
```

**Steps:**
1. **Run Without @ComponentScan:**
   - Uncommented **@ComponentScan** lines.
   - Output:
     ```
     CollaborativeFilter bean found = false
     ContentBasedFilter bean found = true
     ```

2. **Run With @ComponentScan (Lesson10):**
   - Uncomment `@ComponentScan(basePackages = "lesson10")`.
   - Output:
     ```
     CollaborativeFilter bean found = true
     ContentBasedFilter bean found = false
     ```

3. **Run With @ComponentScan (Include Filters):**
   - Uncomment `@ComponentScan(includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = "lesson9.*"))`.
   - Output:
     ```
     CollaborativeFilter bean found = true
     ContentBasedFilter bean found = true
     ```

---

### ** Joke Time! ğŸ˜…**

> **Q:** Spring mein @ComponentScan bina specify kiye beans dhundhne mein kya karta hai?
>
> **A:** "Arre yaar, main sirf apne area mein ghusunga, baahar ki beans ko mat bula!" ğŸ˜‚

*(Yahan "area" ka matlab hai base package, aur "baahar ki beans" matlab alag packages mein beans!)*

---

### **Summary**

- **@ComponentScan** Spring ko batata hai ki kin packages mein beans ko scan karna hai.
- **@SpringBootApplication** automatically scan karta hai us package ko jahan ye present hai aur uske sub-packages ko.
- Agar aapke beans alag packages mein hain, toh **@ComponentScan** ka use karke specify kar sakte hain.
- **Include aur Exclude Filters** ka use karke specific beans ko include ya exclude kar sakte hain.
- **Filter Types** mein **ANNOTATION**, **ASPECTJ**, **ASSIGNABLE_TYPE**, **REGEX**, aur **CUSTOM** shamil hain.
- **Diagrams aur Code Examples** se samajhne mein aasan ho jata hai ki Spring kaise beans ko manage karta hai.

---

### **Final Joke for Memory**

> **Q:** Spring Boot application mein @ComponentScan ke bina beans scan nahi kar paate, toh kya kehte hain?
>
> **A:** "Arey, yeh Spring bhi na, apni hi gali mein rehna pasand karta hai!" ğŸ˜‚

*(Yahan "apni hi gali" matlab base package, aur "baahar ki gali" matlab alag packages!)*

---
